---
// Hero Swiper using Swiper JS (no React needed)
// Props: screenshots: string[] (public paths), eager?: boolean, trackColor?: string (CSS color/var)
type HeroSwiperProps = {
  screenshots?: string[]
  eager?: boolean
  trackColor?: string
}

const {
  screenshots = [],
  eager = false,
  trackColor = 'var(--hero-swiper-track-color, #f5f5f5)',
} = Astro.props as HeroSwiperProps
---

<div class="hero-swiper" style={`--hero-swiper-track:${trackColor}`}>
  <div class="swiper hero-swiper__instance no-scrollbar">
    <div class="swiper-wrapper">
      {screenshots.map((src: string, i: number) => (
        <div class="swiper-slide">
      <div class="hero-slide">
            <img
              src={src}
              alt="Скриншот демо AI Hair Extension Bot"
              loading={(eager || i === 0) ? 'eager' : 'lazy'}
              fetchpriority={(eager || i === 0) ? 'high' : 'auto'}
              decoding="async"
            />
          </div>
        </div>
      ))}
    </div>
  </div>
  <div class="hero-swiper__dots" role="group" aria-label="Скриншоты">
    {screenshots.map((_: string, idx: number) => (
      <button
        type="button"
        class="hero-swiper__dot"
        data-slide={idx}
        aria-label={`Показать слайд ${idx + 1}`}
      ></button>
    ))}
  </div>
</div>

<style is:global>
  @import 'swiper/css';
  @import 'swiper/css/free-mode';
</style>

<style>
  .hero-swiper {
    @apply relative block w-full;
    --hero-swiper-track: #f5f5f5;
  }
  .hero-swiper__instance {
    @apply relative block w-full;
  }
  .swiper-wrapper { align-items: flex-end; }
  .swiper-slide { width: auto !important; }
  .no-scrollbar::-webkit-scrollbar { display: none; }
  .no-scrollbar { -ms-overflow-style: none; scrollbar-width: none; }
  .hero-slide {
    @apply inline-block h-[60vh] max-h-[640px] overflow-hidden rounded-3xl shadow-2xl shadow-neutral-200 dark:shadow-neutral-950;
  }
  .hero-slide img { @apply block h-full w-auto object-contain; }

  .hero-swiper__dots {
    @apply mt-6 mb-5 flex items-center justify-center gap-2;
  }
  .hero-swiper__dot {
    @apply h-2 w-2 rounded-full bg-neutral-400 transition-all duration-300 ease-out;
  }
  .hero-swiper__dot.is-active {
    @apply w-6 bg-primary-400;
  }
  .hero-swiper__dots[hidden] {
    display: none;
  }

  /* Progressive enhancement: show slides even before Swiper boots */
  .hero-swiper__instance:not(.swiper-initialized) .swiper-wrapper {
    display: flex;
    gap: 2rem;
    justify-content: center;
  }
  .hero-swiper__instance:not(.swiper-initialized) .swiper-slide {
    flex: 0 0 auto;
    opacity: 1;
  }

  :global(.dark) .hero-swiper {
    --hero-swiper-track: var(--hero-swiper-track-dark, #111827);
  }

  /* Scope overflow fix only to this hero swiper */
  .hero-swiper,
  .hero-swiper :is(.swiper, .swiper-wrapper, .swiper-slide) {
    overflow: visible !important;
    will-change: transform, opacity;
    transform: translateZ(0);
  }
</style>

<script>
  if (typeof window !== 'undefined') {
    type HeroSwiperInstance = import('swiper').default

    const initHeroSwipers = async () => {
      const { default: Swiper } = await import('swiper/bundle')

      document
        .querySelectorAll<HTMLElement>('.hero-swiper__instance')
        .forEach((container) => {
          const el = container as HTMLElement & { __heroSwiper?: HeroSwiperInstance }
          const dotsContainer = container.parentElement?.querySelector<HTMLElement>('.hero-swiper__dots')
          const dots = Array.from(dotsContainer?.querySelectorAll<HTMLButtonElement>('.hero-swiper__dot') ?? [])
          if (dotsContainer) {
            if (dots.length <= 1) {
              dotsContainer.setAttribute('hidden', '')
            } else {
              dotsContainer.removeAttribute('hidden')
            }
          }

          const updateDots = (activeIndex: number) => {
            dots.forEach((dot, idx) => {
              dot.classList.toggle('is-active', idx === activeIndex)
              dot.disabled = idx === activeIndex
            })
          }

          if (el.__heroSwiper?.destroyed) {
            el.__heroSwiper = undefined
          }
          if (el.__heroSwiper) {
            const swiper = el.__heroSwiper
            swiper.update()
            updateDots(swiper.activeIndex ?? 0)
            return
          }

          const swiper = new Swiper(container, {
            slidesPerView: 'auto',
            spaceBetween: 32,
            centeredSlides: true,
            centeredSlidesBounds: true,
            initialSlide: 0,
            speed: 600,
            loop: false,
            allowTouchMove: true,
            grabCursor: true,
            slideToClickedSlide: false,
            watchSlidesProgress: true,
            observer: true,
            observeParents: true,
            observeSlideChildren: true,
          })

          swiper.on('afterInit', () => {
            swiper.updateSlides()
            swiper.slideTo(0, 0)
            updateDots(swiper.activeIndex ?? 0)
          })

          swiper.once('init', () => {
            updateDots(swiper.activeIndex ?? 0)
          })
          requestAnimationFrame(() => {
            updateDots(swiper.activeIndex ?? 0)
            swiper.update()
          })

          const ensureVisible = () => {
            swiper.updateSlides()
            swiper.updateProgress()
            swiper.updateSlidesClasses()
            swiper.slideTo(0, 0)
            updateDots(swiper.activeIndex ?? 0)
          }

          const images = Array.from(container.querySelectorAll('img'))
          let pending = images.length
          if (pending === 0) {
            ensureVisible()
          } else {
            const handleReady = () => {
              pending = Math.max(0, pending - 1)
              if (pending === 0) {
                ensureVisible()
              }
            }
            images.forEach((img) => {
              if (img.complete) {
                handleReady()
              } else {
                img.addEventListener('load', handleReady, { once: true })
                img.addEventListener('error', handleReady, { once: true })
              }
            })
            // Safety timeout in case some resources never fire events
            setTimeout(ensureVisible, 400)
          }

          swiper.on('slideChange', () => {
            updateDots(swiper.activeIndex ?? 0)
          })

          const handleDotClick = (event: Event) => {
            const button = event.currentTarget as HTMLButtonElement
            const index = Number(button.dataset.slide ?? '0')
            if (Number.isFinite(index)) {
              swiper.slideTo(index, 600)
            }
          }

          dots.forEach((dot) => {
            dot.addEventListener('click', handleDotClick)
          })

          const handleNextClick = (event: MouseEvent) => {
            const target = event.target as Element | null
            if (target?.closest('a,button,[role="button"],input,textarea,select')) return
            const total = swiper.slides?.length ?? 0
            const current = swiper.activeIndex ?? 0
            if (total > 0 && current < total - 1) {
              swiper.slideNext(600)
            }
          }

          container.addEventListener('click', handleNextClick)

          el.__heroSwiper = swiper
        })
    }

    const ensureInit = () => {
      initHeroSwipers().catch((err) => {
        console.error('Failed to init hero swiper', err)
      })
    }

    ensureInit()
    window.addEventListener('resize', () => {
      requestAnimationFrame(ensureInit)
    })
    window.addEventListener('load', ensureInit, { once: true })
    document.addEventListener('astro:page-load', ensureInit)
  }
</script>
