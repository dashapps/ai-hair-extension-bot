---
// Hero Swiper using Swiper Element (no React needed)
// Props: screenshots: string[] (public paths), eager?: boolean
const { screenshots = [], eager = false } = Astro.props as {
  screenshots?: string[]
  eager?: boolean
}
---

<swiper-container
  class="hero-swiper no-scrollbar"
  slides-per-view="auto"
  space-between="32"
  grab-cursor="true"
  slides-per-group="1"
  speed="500"
  centered-slides="true"
  initial-slide="0"
  
>
  {screenshots.map((src: string, i: number) => (
    <swiper-slide>
      <div class="hero-slide">
        <img src={src} alt="Скриншот демо AI Hair Extension Bot" loading={(eager || i === 0) ? 'eager' : 'lazy'} fetchpriority={(eager || i === 0) ? 'high' : 'auto'} decoding="async" />
      </div>
    </swiper-slide>
  ))}
</swiper-container>

<style is:global>
  @import 'swiper/css';
  @import 'swiper/css/free-mode';
</style>

<style>
  .hero-swiper { @apply block w-full items-end; }
  swiper-slide { width: auto !important; }
  .no-scrollbar::-webkit-scrollbar { display: none; }
  .no-scrollbar { -ms-overflow-style: none; scrollbar-width: none; }
  .hero-slide {
    @apply inline-block h-[60vh] max-h-[640px] overflow-hidden rounded-t-2xl shadow-2xl shadow-neutral-200 dark:shadow-neutral-950;
  }
  .hero-slide img { @apply block h-full w-auto object-contain; }

  /* Scope overflow fix only to this hero swiper */
  .hero-swiper,
  .hero-swiper :is(.swiper, .swiper-wrapper, .swiper-slide),
  .hero-swiper swiper-slide {
    overflow: visible !important;
    will-change: transform, opacity;
    transform: translateZ(0);
  }
</style>

<script>
  import { register } from 'swiper/element/bundle'

  interface SwiperContainer extends HTMLElement {
    swiper?: {
      slideTo: (index: number, speed?: number) => void
      slideNext: () => void
      slidePrev: () => void
    }
    update?: () => void
    slidesPerGroup?: number
    speed?: number
  }

  if (!customElements.get('swiper-container')) register()
  if (typeof window !== 'undefined') {
    // no offset; rely on centered-slides
    const updateAll = () => {
      document
        .querySelectorAll<SwiperContainer>('swiper-container.hero-swiper')
        .forEach((el) => el.update?.())
    }
    updateAll()
    window.addEventListener('resize', updateAll)
    // Interactions: click/tap or keys move exactly one slide (no scaling)
    const els = document.querySelectorAll<SwiperContainer>('swiper-container.hero-swiper')
    els.forEach((el) => {
      // Force start from first slide centered
      let tries = 0
      const ensureFirstCentered = () => {
        if (el.swiper?.slideTo) {
          el.swiper.slideTo(0, 0)
        } else if (tries++ < 40) {
          requestAnimationFrame(ensureFirstCentered)
        }
      }
      ensureFirstCentered()
      el.slidesPerGroup = 1
      el.speed = 500
      // focusable for keyboard
      el.tabIndex = 0
      // click anywhere except interactive child -> next by one
      el.addEventListener('click', (e) => {
        const t = e.target as HTMLElement | null
        if (t && t.closest?.('a,button,[role="button"],input,textarea,select')) return
        el.swiper?.slideNext()
      })
      el.addEventListener('keydown', (e: KeyboardEvent) => {
        if (e.key === 'ArrowRight' || e.key === 'Enter' || e.key === ' ' || e.key === 'Tab') {
          e.preventDefault()
          el.swiper?.slideNext()
        } else if (e.key === 'ArrowLeft') {
          e.preventDefault()
          el.swiper?.slidePrev()
        }
      })
      // extra: ensure tap/pointer triggers next as well
      el.addEventListener('pointerup', (e) => {
        const t = e.target as HTMLElement | null
        if (t && t.closest?.('a,button,[role="button"],input,textarea,select')) return
        el.swiper?.slideNext()
      })
    })
  }
</script>
